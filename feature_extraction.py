# feature_extraction.py
import fitz
import os
import pandas as pd
import subprocess
import time
import shutil
from io import StringIO 




def extract_pdfid_features(pdf_path):
    var = str(r"tr '\n' ','")
    header = ['header', 'obj', 'endobj', 'stream', 'endstream', 'xref', 'trailer', 'startxref', 'pageno', 'encrypt', 'ObjStm', 'JS', 'Javascript', 'AA', 'OpenAction', 'Acroform', 'JBIG2Decode', 'RichMedia', 'launch', 'EmbeddedFile', 'XFA', 'URI', 'Colors']
    
    # Capture the output in memory instead of writing to a file
    output_csv = StringIO()
    output_csv.write(','.join(header))

    # Set the working directory to the pdfid folder
    repo_root = os.path.dirname(os.path.abspath(__file__))
    pdfid_folder = os.path.join(repo_root, 'pdfid')
    os.chdir(pdfid_folder)

    t0 = time.time()

    # Use the provided PDF path from Streamlit
    f = pdf_path
    # out = subprocess.getoutput(f"python pdfid.py {f} | awk '{{print $2}}' | tail -n +2 | {var}")
    # out = out.replace(",>,,", "")
    # output_csv.write("\n" + out)

    out_full = subprocess.getoutput(f'''python pdfid.py "{f}"''')
    if "PDF Header" not in out_full:
        out = subprocess.getoutput(f'''echo "{out_full}" | tail -n +2 | {var}''')
        out = out.replace(',', '')
        out += ',-1'  * (max_len - 1)
    else:
        out = subprocess.getoutput(f'''echo "{out_full}" | awk '{{print $NF}}' | tail -n +2 | {var}''')
    out = out.rstrip(',') # remove the trailing commas from the `out` string
    output_csv.write("\n" + out)

    d = time.time() - t0
    print("duration: %.2f s." % d)

    # Move the cursor to the beginning of the StringIO object
    output_csv.seek(0)

    # Read the CSV content into a DataFrame
    pdfid_features_df = pd.read_csv(output_csv)

    return pdfid_features_df


def extract_features(pdf_path):
    res = pd.DataFrame(columns=('pdfsize', 'metadataSize', 'pages', 'xrefLength', 'titleCharacters', 'isEncrypted', 'embeddedFiles', 'images', 'text'))

    i = 0

    # try:
    #     doc = fitz.open(pdf_path)
    # except:
    #     print("Error opening PDF:", pdf_path)
    #     # Handle the error appropriately
    #     return res

    # metadata = doc.metadata
    # isEncrypted = 0

    # if metadata:
    #     title = metadata.get('title', '')
    #     isEncrypted = metadata['encryption']
    #     if not isEncrypted:
    #         isEncrypted = 0
    #     else:
    #         isEncrypted = 1

    # objects = doc.xref_length()
    # numPages = doc.page_count
    # pdfsize = int(os.path.getsize(pdf_path) / 1000)

    # found = "No"
    # text = ""

    # try:
    #     for page in doc:
    #         text += page.get_text()
    #         if len(text) > 100:
    #             found = "Yes"
    #             break
    # except:
    #     found = "unclear"
    #     res.loc[i] = [pdfsize, len(str(metadata).encode('utf-8'))] + [numPages] + [objects] + [len(title)] + [isEncrypted] + [-1] + [-1] + [found]
    #     return res

    # embedcount = 0
    # try:
    #     embedcount = doc.embfile_count()
    # except Exception as e:
    #     print("Error processing PDF:", pdf_path)
    #     print("Error details:", str(e))
    #     embedcount = -1

    # imgcount = 0
    # try:
    #     for k in range(len(doc)):
    #         page = doc[k]
    #         image_list = page.get_images()
    #         imgcount += len(image_list)
    # except Exception as e:
    #     imgcount = -1

    f = pdf_path
    pdfsize = int(os.path.getsize(f) / 1000)
    # print("pdfsize is " + str(pdfsize))

    # Dependent attributes
    try:
        doc = fitz.open(f)
        metadata = doc.metadata
        metadata_size = len(str(metadata).encode('utf-8'))
        pages = doc.page_count
        xref_length = doc.xref_length()
        title_characters = len(metadata.get('title', ''))
        isEncrypted = 1 if metadata and metadata['encryption'] else 0
        embedded_files = doc.embfile_count()

        imgcount = 0
        try:
            imgcount = sum(len(page.get_images()) for page in doc)
        except Exception as e:
            imgcount = -1
            # print(f'Error get_images PDF: "{j}". Error: {e}')

        contains_text = "No"
        try:
            for page in doc:
                if len(page.get_text()) > 100:
                    contains_text = "Yes"
                    break
        except Exception as e:
            contains_text = "unclear"
            # print(f'Error get_text PDF: "{j}". Error: {e}')
        # Đóng tài liệu sau khi hoàn thành xử lý
        doc.close()
    except Exception as e:
        print(f'Error opening PDF: "{j}". Error details: {str(e)}.')
        metadata_size = title_characters = isEncrypted = xref_length = pages = embedded_files = imgcount = contains_text = -1

    res.loc[i] = [pdfsize, metadata_size] + [pages] + [xref_length] + [title_characters] + [isEncrypted] + [embedded_files] + [imgcount] + [contains_text]

    # doc.close()
    # return res
    
    # Extract PDFiD features
    pdfid_features_df = extract_pdfid_features(pdf_path)

    # Merge the general features with PDFiD features
    features_df = pd.concat([res, pdfid_features_df], axis=1)
    features_df = features_df.fillna(-1)

    # Str to Num
    features_df = features_df.map(convert_to_number)
    
    # return pdfid_features_df
    return features_df


def save_features_to_csv(features_df, output_path):
    features_df.to_csv(output_path, index=False)
    print("Features extracted successfully and saved to CSV.")

def convert_to_number(value):
    try:
        return int(value)
    except (ValueError, TypeError):
        return value

