# feature_extraction.py
import fitz
import os
import pandas as pd
import subprocess
import time
import shutil
from io import StringIO 




def extract_pdfid_features(pdf_path):
    var = str(r"tr '\n' ','")
    header = ['header', 'obj', 'endobj', 'stream', 'endstream', 'xref', 'trailer', 'startxref', 'pageno', 'encrypt', 'ObjStm', 'JS', 'Javascript', 'AA', 'OpenAction', 'Acroform', 'JBIG2Decode', 'RichMedia', 'launch', 'EmbeddedFile', 'XFA', 'Colors']

    # Capture the output in memory instead of writing to a file
    output_csv = StringIO()
    output_csv.write(','.join(header))

    # Set the working directory to the pdfid folder
    repo_root = os.path.dirname(os.path.abspath(__file__))
    pdfid_folder = os.path.join(repo_root, 'pdfid')
    os.chdir(pdfid_folder)

    t0 = time.time()

    # Use the provided PDF path from Streamlit
    f = pdf_path
    out = subprocess.getoutput(f"python pdfid.py {f} | awk '{{print $2}}' | tail -n +2 | {var}")
    out = out.replace(",>,,", "")
    output_csv.write("\n" + out)

    d = time.time() - t0
    print("duration: %.2f s." % d)

    # Move the cursor to the beginning of the StringIO object
    output_csv.seek(0)

    # Read the CSV content into a DataFrame
    pdfid_features_df = pd.read_csv(output_csv)

    return pdfid_features_df


def extract_features(pdf_path):
    res = pd.DataFrame(columns=('pdfsize', 'metadata size', 'pages', 'xref length', 'title characters', 'isEncrypted', 'embedded files', 'images', 'contains text'))

    i = 0

    try:
        doc = fitz.open(pdf_path)
    except:
        print("Error opening PDF:", pdf_path)
        # Handle the error appropriately
        return res

    metadata = doc.metadata
    isEncrypted = 0

    if metadata:
        title = metadata.get('title', '')
        isEncrypted = metadata['encryption']
        if not isEncrypted:
            isEncrypted = 0
        else:
            isEncrypted = 1

    objects = doc.xref_length()
    numPages = doc.page_count
    pdfsize = int(os.path.getsize(pdf_path) / 1000)

    found = "No"
    text = ""

    try:
        for page in doc:
            text += page.get_text()
            if len(text) > 100:
                found = "Yes"
                break
    except:
        found = "unclear"
        res.loc[i] = [pdfsize, len(str(metadata).encode('utf-8'))] + [numPages] + [objects] + [len(title)] + [isEncrypted] + [-1] + [-1] + [found]
        return res

    embedcount = 0
    try:
        embedcount = doc.embfile_count()
    except Exception as e:
        print("Error processing PDF:", pdf_path)
        print("Error details:", str(e))
        embedcount = -1

    imgcount = 0
    try:
        for k in range(len(doc)):
            page = doc[k]
            image_list = page.get_images()
            imgcount += len(image_list)
    except Exception as e:
        imgcount = -1

    res.loc[i] = [pdfsize, len(str(metadata).encode('utf-8'))] + [numPages] + [objects] + [len(title)] + [isEncrypted] + [embedcount] + [imgcount] + [found]

    doc.close()
    # return res
    
    # Extract PDFiD features
    pdfid_features_df = extract_pdfid_features(pdf_path)

    # Merge the general features with PDFiD features
    features_df = pd.concat([res, pdfid_features_df], axis=1)
    features_df = features_df.fillna(-1)

    # Str to Num
    features_df = features_df.map(convert_to_number)
    
    # return pdfid_features_df
    return features_df


def save_features_to_csv(features_df, output_path):
    features_df.to_csv(output_path, index=False)
    print("Features extracted successfully and saved to CSV.")

def convert_to_number(value):
    try:
        return int(value)
    except (ValueError, TypeError):
        return value

